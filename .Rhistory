View(res)
run_process_silent(params, initial_hosts) |> profvis::profvis()
run_process_silent(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) |> profvis::profvis()
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) |> profvis::profvis()
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
################################################################################
source("./R/run_process_silent2.R")
library(Rcpp)
sourceCpp("./CPP/fastMin.cpp")
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) |> profvis::profvis()
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
run_process_silent2(params, initial_hosts) |> profvis::profvis()
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts)
run_process_silent2(params, initial_hosts) -> res
res
View(res)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) -> res
View(res)
################################################################################
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) -> res
View(res)
run_process_silent(params, initial_hosts) -> res
View(res)
# Mission: améliorer run_process_silent()
source("./config.R") # Loading params
source("./R/run_process_silent.R") # Load original function
source("./R/generate_init.R") # Creating initial hosts pop
initial_hosts <- params |> generate_init()
run_process_silent(params, initial_hosts) -> res
View(res)
# IMPORT ------------------------------------------------------------------
# Import simulation results
res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/2025-03-26_10:36:27.rds")
# IMPORT ------------------------------------------------------------------
# Import simulation results
res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/2025-03-26_10:36:27.rds")
# WRANGLING ---------------------------------------------------------------
# Identify unique parameter sets
param_sets <- list()
results_by_params <- list()
# Extract parameter values
for(i in 1:length(res)) {
param_id <- paste(
res[[i]]$params$init$N,
res[[i]]$params$init$p0,
res[[i]]$params$events$r_mig,
res[[i]]$params$events$r_kill,
res[[i]]$params$events$strat,
sep = "_"
)
if(!(param_id %in% names(results_by_params))) {
results_by_params[[param_id]] <- list()
param_sets[[param_id]] <- res[[i]]$params
}
results_by_params[[param_id]] <- c(results_by_params[[param_id]], list(res[[i]]$results))
}
# Calculate means at each timepoint across replicates
summary_results <- lapply(names(results_by_params), function(param_id) {
reps <- results_by_params[[param_id]]
n_timepoints <- nrow(reps[[1]])
# Create empty matrices for each variable
all_min <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_max <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_mean <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_killed <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_total <- matrix(0, nrow=n_timepoints, ncol=length(reps))
# Fill matrices with data from each replicate
for(j in 1:length(reps)) {
all_min[,j] <- reps[[j]]$min
all_max[,j] <- reps[[j]]$max
all_mean[,j] <- reps[[j]]$mean
all_killed[,j] <- reps[[j]]$killed_hosts
all_total[,j] <- reps[[j]]$total_end
}
# Calculate row means (across replicates)
list(
params = param_sets[[param_id]],
results = data.frame(
min = rowMeans(all_min, na.rm = TRUE),
max = rowMeans(all_max, na.rm = TRUE),
mean = rowMeans(all_mean, na.rm = TRUE),
killed_hosts = rowMeans(all_killed, na.rm = TRUE),
total_end = rowMeans(all_total, na.rm = TRUE)
)
)
})
# Return the same structure as input but with averaged results
names(summary_results) <- names(results_by_params)
# PLOT --------------------------------------------------------------------
# Function to plot one parameter set
plot_results <- function(result) {
df <- result$results
time <- 1:nrow(df)
param <- result$params
# Create main plot
plot(time, df$mean, type="l", lwd=2,
main=sprintf("N=%d, p0=%g, r_mig=%g, r_kill=%g, n_rep=%s",
param$init$N, param$init$p0,
param$events$r_mig, param$events$r_kill,
param$other$n_rep),
xlab="Tau", ylab="Number of TEs",
ylim=c(min(df$min, na.rm = TRUE),500),
log = "y")
# Add min/max as dashed lines
lines(time, df$min, lty=2, col="blue")
lines(time, df$max, lty=2, col="red")
# Add legend
legend("topright", legend=c("Mean", "Min", "Max"),
col=c("black", "blue", "red"),
lty=c(1, 2, 2), lwd=c(2, 1, 1))
grid()
}
# Plot all results sequentially
names(summary_results)
for(i in seq_along(summary_results)){
plot_results(summary_results[[i]])
}
View(summary_results)
View(results_by_params)
# SUMMARIZE ---------------------------------------------------------------
cli::cli_h2("SUMMARIZE")
# Importing the most recent file of ./RESULTS directory
rds_files <- list.files(path = "./RESULTS", pattern = "\\.rds$", full.names = TRUE)
if (length(rds_files) > 0) {
most_recent_file <- rds_files[which.max(file.info(rds_files)$mtime)]
res <- readRDS(most_recent_file)
cat(most_recent_file, "have been imported succesfully (most recent file of the directory)\n")
} else {
stop("No .rds files found in the specified directory")
}
# Print available parameters
cat("------ Available parameters ------\n\n")
available_r_mig  <-  sapply(res, function(x) x$params$events$r_mig) |> unique()
available_r_kill <- sapply(res, function(x) x$params$events$r_kill) |> unique()
cat("r_mig:  ", available_r_mig, "\n")
cat("r_kill: ", available_r_kill, "\n")
# Select from available parameters
selected_r_mig  <- available_r_mig[8]
selected_r_kill <- available_r_kill[1]
# Filter the res list according to choosen r_mig & r_kill
res_filtered <- res[sapply(res, function(x) {
isTRUE(x$params$events$r_mig == selected_r_mig &
x$params$events$r_kill == selected_r_kill)})] |>
lapply(function(x) x$results)
# Create a 'mean result' data-frame
mean_res <- Reduce(`+`, res_filtered) / length(res_filtered)
# Generate plots
tau <- res[[1]]$params$other$tau
predicted_mean <- 1 + (selected_r_mig / selected_r_kill)
my_alpha = 0.4
plot(
x = 1:tau,
y = res_filtered[[1]]$mean,
type = "l",
col =  adjustcolor("darkred", alpha.f = my_alpha),
lwd = 3,
xlab = "Generations",
ylab = "Count",
ylim = c(0, predicted_mean + 10),
main = paste0(
"PARAMETERS :      ",
"N = ",
res[[1]]$params$init$N,
"   |   ",
"R_mig = ",
res[[1]]$params$events$r_mig,
"   |   ",
"R_kill = ",
res[[1]]$params$events$r_kill
)
)
# IMPORT ------------------------------------------------------------------
# Import simulation results
# res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/2025-03-26_10:36:27.rds")
res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/cluster_2025-03-26_10:31:23.rds")
# WRANGLING ---------------------------------------------------------------
# Identify unique parameter sets
param_sets <- list()
results_by_params <- list()
# Extract parameter values
for(i in 1:length(res)) {
param_id <- paste(
res[[i]]$params$init$N,
res[[i]]$params$init$p0,
res[[i]]$params$events$r_mig,
res[[i]]$params$events$r_kill,
res[[i]]$params$events$strat,
sep = "_"
)
if(!(param_id %in% names(results_by_params))) {
results_by_params[[param_id]] <- list()
param_sets[[param_id]] <- res[[i]]$params
}
results_by_params[[param_id]] <- c(results_by_params[[param_id]], list(res[[i]]$results))
}
# Calculate means at each timepoint across replicates
summary_results <- lapply(names(results_by_params), function(param_id) {
reps <- results_by_params[[param_id]]
n_timepoints <- nrow(reps[[1]])
# Create empty matrices for each variable
all_min <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_max <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_mean <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_killed <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_total <- matrix(0, nrow=n_timepoints, ncol=length(reps))
# Fill matrices with data from each replicate
for(j in 1:length(reps)) {
all_min[,j] <- reps[[j]]$min
all_max[,j] <- reps[[j]]$max
all_mean[,j] <- reps[[j]]$mean
all_killed[,j] <- reps[[j]]$killed_hosts
all_total[,j] <- reps[[j]]$total_end
}
# Calculate row means (across replicates)
list(
params = param_sets[[param_id]],
results = data.frame(
min = rowMeans(all_min, na.rm = TRUE),
max = rowMeans(all_max, na.rm = TRUE),
mean = rowMeans(all_mean, na.rm = TRUE),
killed_hosts = rowMeans(all_killed, na.rm = TRUE),
total_end = rowMeans(all_total, na.rm = TRUE)
)
)
})
# Return the same structure as input but with averaged results
names(summary_results) <- names(results_by_params)
# PLOT --------------------------------------------------------------------
# Function to plot one parameter set
plot_results <- function(result) {
df <- result$results
time <- 1:nrow(df)
param <- result$params
# Create main plot
plot(time, df$mean, type="l", lwd=2,
main=sprintf("N=%d, p0=%g, r_mig=%g, r_kill=%g, n_rep=%s",
param$init$N, param$init$p0,
param$events$r_mig, param$events$r_kill,
param$other$n_rep),
xlab="Tau", ylab="Number of TEs",
ylim=c(min(df$min, na.rm = TRUE),500),
log = "y")
# Add min/max as dashed lines
lines(time, df$min, lty=2, col="blue")
lines(time, df$max, lty=2, col="red")
# Add legend
legend("topright", legend=c("Mean", "Min", "Max"),
col=c("black", "blue", "red"),
lty=c(1, 2, 2), lwd=c(2, 1, 1))
grid()
}
# Plot all results sequentially
names(summary_results)
for(i in seq_along(summary_results)){
plot_results(summary_results[[i]])
}
View(res)
test <- res[[1]]$results
head(test)
tail(test)
table(test$min)
test <- res[[2]]$results
table(test$min)
test <- res[[3]]$results
table(test$min)
test <- res[[4]]$results
table(test$min)
test <- res[[3]]$results
plot(test$min)
res <- res[[1]]
# IMPORT ------------------------------------------------------------------
# Import simulation results
# res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/2025-03-26_10:36:27.rds")
res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/cluster_2025-03-26_10:31:23.rds")
res <- res[[1]]
# WRANGLING ---------------------------------------------------------------
# Identify unique parameter sets
param_sets <- list()
results_by_params <- list()
# Extract parameter values
for(i in 1:length(res)) {
param_id <- paste(
res[[i]]$params$init$N,
res[[i]]$params$init$p0,
res[[i]]$params$events$r_mig,
res[[i]]$params$events$r_kill,
res[[i]]$params$events$strat,
sep = "_"
)
if(!(param_id %in% names(results_by_params))) {
results_by_params[[param_id]] <- list()
param_sets[[param_id]] <- res[[i]]$params
}
results_by_params[[param_id]] <- c(results_by_params[[param_id]], list(res[[i]]$results))
}
# IMPORT ------------------------------------------------------------------
# Import simulation results
# res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/2025-03-26_10:36:27.rds")
res <- readRDS("~/REMOTE_SHARED/WIAS_transposons/RESULTS/cluster_2025-03-26_10:31:23.rds")
# WRANGLING ---------------------------------------------------------------
# Identify unique parameter sets
param_sets <- list()
results_by_params <- list()
# Extract parameter values
for(i in 1:length(res)) {
param_id <- paste(
res[[i]]$params$init$N,
res[[i]]$params$init$p0,
res[[i]]$params$events$r_mig,
res[[i]]$params$events$r_kill,
res[[i]]$params$events$strat,
sep = "_"
)
if(!(param_id %in% names(results_by_params))) {
results_by_params[[param_id]] <- list()
param_sets[[param_id]] <- res[[i]]$params
}
results_by_params[[param_id]] <- c(results_by_params[[param_id]], list(res[[i]]$results))
}
# Calculate means at each timepoint across replicates
summary_results <- lapply(names(results_by_params), function(param_id) {
reps <- results_by_params[[param_id]]
n_timepoints <- nrow(reps[[1]])
# Create empty matrices for each variable
all_min <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_max <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_mean <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_killed <- matrix(0, nrow=n_timepoints, ncol=length(reps))
all_total <- matrix(0, nrow=n_timepoints, ncol=length(reps))
# Fill matrices with data from each replicate
for(j in 1:length(reps)) {
all_min[,j] <- reps[[j]]$min
all_max[,j] <- reps[[j]]$max
all_mean[,j] <- reps[[j]]$mean
all_killed[,j] <- reps[[j]]$killed_hosts
all_total[,j] <- reps[[j]]$total_end
}
# Calculate row means (across replicates)
list(
params = param_sets[[param_id]],
results = data.frame(
min = rowMeans(all_min, na.rm = TRUE),
max = rowMeans(all_max, na.rm = TRUE),
mean = rowMeans(all_mean, na.rm = TRUE),
killed_hosts = rowMeans(all_killed, na.rm = TRUE),
total_end = rowMeans(all_total, na.rm = TRUE)
)
)
})
# Return the same structure as input but with averaged results
names(summary_results) <- names(results_by_params)
# PLOT --------------------------------------------------------------------
# Function to plot one parameter set
plot_results <- function(result) {
df <- result$results
time <- 1:nrow(df)
param <- result$params
# Create main plot
plot(time, df$mean, type="l", lwd=2,
main=sprintf("N=%d, p0=%g, r_mig=%g, r_kill=%g, n_rep=%s",
param$init$N, param$init$p0,
param$events$r_mig, param$events$r_kill,
param$other$n_rep),
xlab="Tau", ylab="Number of TEs",
ylim=c(min(df$min, na.rm = TRUE),500),
log = "y")
# Add min/max as dashed lines
lines(time, df$min, lty=2, col="blue")
lines(time, df$max, lty=2, col="red")
# Add legend
legend("topright", legend=c("Mean", "Min", "Max"),
col=c("black", "blue", "red"),
lty=c(1, 2, 2), lwd=c(2, 1, 1))
grid()
}
# Plot all results sequentially
names(summary_results)
for(i in seq_along(summary_results)){
plot_results(summary_results[[i]])
}
################################################################################
# To plot only one replicate
plot_results(res[[1]])
################################################################################
# To plot only one replicate
plot_results(res[[2]])
################################################################################
# To plot only one replicate
for(i in seq_along(res)){
plot_results(res[[i]])
}
# To plot only one replicate
for(i in seq_along(res)){
plot_results(res[[i]])
}
# Mission: améliorer run_process_silent()
source("./config.R") # Loading params
source("./R/run_process_silent.R") # Load original function
source("./R/generate_init.R") # Creating initial hosts pop
initial_hosts <- params |> generate_init()
run_process_silent(params, initial_hosts) -> res
run_process_silent(params, initial_hosts) |> profvis::profvis()
run_process_silent(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
source("./R/run_process_silent2.R")
run_process_silent2(params, initial_hosts) -> res
run_process_silent2(params, initial_hosts) |> profvis::profvis()
run_process_silent2(params, initial_hosts) |> microbenchmark::microbenchmark(times = 10)
View(res)
head(table(res$min))
head(table(res$min), 20)
head(table(res$min), 20) |> plt()
head(table(res$min), 20) |> plot()
head(table(res$min), 20) |> barplot()
head(table(res$min), 20) |> log() |> barplot()
head(table(res$min), 100) |> log() |> barplot()
head(table(res$min), 1000) |> log() |> barplot()
table(res$min) |> log() |> barplot()
table(res$min) |> log2() |> barplot()
table(res$min) |> log2() |> density() |> plot()
table(res$min) |> log2() |> barplot()
table(res$min) |> log2() |> barplot(density = density(table(res$min)))
table(res$min) |> log2() |> barplot()
freq_table <- table(res$min) |> log2()
bar_pos <- barplot(freq_table)
density_data <- density(as.numeric(table(log2(res$min))))
par(new = TRUE)  # This allows the next plot to be overlaid on the current one
plot(density_data$x, density_data$y, type = "l",
col = "darkred", lwd = 2,
xlim = range(bar_pos),  # Match the x-axis range of the barplot
axes = FALSE, xlab = "", ylab = "")  # Suppress axis labels
axis(4)
mtext("Density", side = 4, line = 3)
legend("topright", legend = c("Log2 Frequency", "Density"),
fill = c("gray", NA), border = c("black", NA),
lty = c(NA, 1), col = c(NA, "darkred"), merge = TRUE)
freq_table <- table(res$min) |> log2()
bar_pos <- barplot(freq_table)
density_data <- density(as.numeric(table(log2(res$min))))
par(new = TRUE)  # This allows the next plot to be overlaid on the current one
plot(density_data$x, density_data$y, type = "l",
col = "darkred", lwd = 2,
xlim = range(bar_pos),  # Match the x-axis range of the barplot
axes = FALSE, xlab = "", ylab = "")  # Suppress axis labels
freq_table <- table(res$min) |> log2()
bar_pos <- barplot(freq_table)
density_data <- density(as.numeric(table((res$min)))) |> log2()
# Usefull plot ?
freq_table <- table(res$min) |> log2()
# Usefull plot ?
freq_table <- res$min |> log2() |> table()
bar_pos <- barplot(freq_table)
# Usefull plot ?
freq_table <- res$min |> table() |> log2()
freq_table
# Usefull plot ?
plot(table(res$min))
# Usefull plot ?
plot(table(res$min), log = "y")
# Usefull plot ?
barplot(table(res$min), log = "y")
density_data <- density(as.numeric(table(res$min |> log2())))
# Add the density curve to the plot
par(new = TRUE)  # This allows the next plot to be overlaid on the current one
# Plot the density curve, adjusting for the barplot's x-axis scale
plot(density_data$x, density_data$y, type = "l",
col = "darkred", lwd = 2,
xlim = range(bar_pos),  # Match the x-axis range of the barplot
axes = FALSE, xlab = "", ylab = "")  # Suppress axis labels
barplot(table(res$min), log = "y")
density_data <- density(as.numeric(table(res$min |> log())))
# Add the density curve to the plot
par(new = TRUE)  # This allows the next plot to be overlaid on the current one
# Plot the density curve, adjusting for the barplot's x-axis scale
plot(density_data$x, density_data$y, type = "l",
col = "darkred", lwd = 2,
xlim = range(bar_pos),
axes = FALSE, xlab = "", ylab = "", log = "y")
# Usefull plot ?
barplot(table(res$min), log = "y")
density_data <- density(as.numeric(table(res$min)))
# Add the density curve to the plot
par(new = TRUE)  # This allows the next plot to be overlaid on the current one
# Plot the density curve, adjusting for the barplot's x-axis scale
plot(density_data$x, density_data$y, type = "l",
col = "darkred", lwd = 2,
xlim = range(bar_pos),
axes = FALSE, xlab = "", ylab = "", log = "y")
# Usefull plot ?
barplot(table(res$min), log = "y")
# Usefull plot ?
barplot(table(res$min * res$min), log = "y")
# Usefull plot ?
barplot(table(res$min), log = "y")
